> x<-1:10
> any(x>8)
[1] TRUE
> any(x>88)
[1] FALSE
> all(x>88)
[1] FALSE
> all(x>0)
[1] TRUE
比较简单，不一一做解释
 
扩展案例：寻找连续出现1的游程
案例描述：一个向量由0和1构成，现在要找到连续出现1的游程，比如对于一组向量（1,0,0,1,1,1,0,1,1）长度为3的游程（连续出现1出现三次）从第4索引开始，长度为2的游程从第4,5,8开始，那么函数返回的结果就应该是（4,5,8）
存在脚本文件（b.R）里面的代码：
findruns<-function(x,k){
  n<-length(x)
  runs<-NULL
  for(i in 1:(n-k+1)){
    if(all(x[i:(i+k-1)]==1))
      runs<-c(runs,i)
  }
  return(runs)
}
控制台里面的代码如下：
> source("b.R")
> y<-c(1,0,0,1,1,1,0,1,1)
> findruns(y,3)
[1] 4
> findruns(y,2)
[1] 4 5 8
> findruns(y,6)
NULL
这个算法还有其他的书写方法，请参考其他资料
 
扩展案例：预测离散值时间顺序
1代表有雨，0代表没有雨，已经知道最近几天是否下雨，来推测明天是否有雨，我们一般用K填的天气记录来预测明天的天气，如果有k/2天下雨，就认为明天会有雨，但是k到底选多少天比较好呢？采取变换不同的k值，看看效果如何。假设有500天的数据，先取k=3,将得到的值与真实值比较，然后取k等于其他值，看看到底哪一个比较好
脚本文件（c.R）里面的数据
preda<-function(x,k){
  n<-length(x)
  k2<-k/2
  pred<-vector(length=n-k)
  for(i in 1:(n-k)){
    if(sum(x[i:(i+(k-1))])>=k2)
      pred[i]<-1
    else
      pred[i]<-0
  }
  return(mean(abs(pred-x[(k+1):n])))
}
控制台的代码
> source("c.R")
> preda(c(0,1,1,1,0,1,0,0,1,0,1,1,0),3)
[1] 0.5
先理解脚本文件里面的返回值，pred-x[(k+1):n]用预测的值（向量）减去真实值（向量）得到的向量会是只包含1,0，-1三个数的向量，然后取绝对值（abs）,然后算平均（mean），平均值越大则预测越不准确（1和-1越多）。
控制台输进去的是一个向量和k的值，通过改变不同的k的值，来确定一个使得预测最准确的k值。
这个算法同样有其他简单的方法，请参考其他相关资料。
